import { PublicKey, Commitment, Connection, Transaction, Signer, TransactionInstruction, Keypair, EpochInfo } from '@solana/web3.js';
import BN__default from 'bn.js';
import { Api } from './api/api.js';
import { av as TxBuilder, an as AddInstructionParam, a7 as BigNumberish, bi as CreateFarm, au as MakeTxData, bj as CreateFarmExtInfo, bk as UpdateFarmReward, bl as UpdateFarmRewards, bm as FarmDWParam, O as FormatFarmInfoOut, bG as ComputeBudgetConfig, at as MakeMultiTxData, l as ApiV3PoolInfoStandardItem, c3 as Percent, b$ as TokenAmount, k as ApiV3PoolInfoConcentratedItem, N as FormatFarmInfoOutV6, bH as LoadParams, C as ClmmKeys, bC as MakeTransaction, bL as ReturnTypeFetchMultipleMintInfos, bE as MakeMultiTransaction, V as OwnerIdoInfo, W as IdoKeysData, J as JupTokenType, bx as TokenInfo, bB as SignAllTransactions, Q as AvailabilityCheckAPI3, f as ApiV3TokenRes, e as ApiV3Token, bI as TransferAmountFee } from './type-f783438f.js';
import { API_URL_CONFIG } from './api/url.js';
import { Owner } from './common/owner.js';
import { PublicKeyish } from './common/pubKey.js';
import { Token } from './module/token.js';
import { Cluster } from './solana/type.js';
import { TokenAccount, TokenAccountRaw, GetOrCreateTokenAccountParams, HandleTokenAccountParams } from './raydium/account/types.js';
import { Logger } from './common/logger.js';
import { TxVersion } from './common/txTool/txType.js';
import Decimal from 'decimal.js';
import { AddLiquidityParams, RemoveParams, CreatePoolParam, CreatePoolAddress } from './raydium/liquidity/type.js';
import { l as CreateConcentratedPool, O as OpenPositionFromBase, o as OpenPositionFromBaseExtInfo, p as OpenPositionFromLiquidity, q as OpenPositionFromLiquidityExtInfo, I as IncreasePositionFromLiquidity, M as ManipulateLiquidityExtInfo, m as IncreasePositionFromBase, D as DecreaseLiquidity, z as ClosePositionExtInfo, r as InitRewardParams, B as InitRewardExtInfo, s as InitRewardsParams, t as SetRewardParams, u as SetRewardsParams, v as CollectRewardParams, w as CollectRewardsParams, H as HarvestAllRewardsParams, N as TickArray, x as ReturnTypeComputeAmountOutBaseOut } from './type-3d09ebbb.js';
import { ClmmPositionLayout } from './raydium/clmm/layout.js';
import { PoolAccountInfoV4, ReturnTypeGetAddLiquidityDefaultPool, ComputeAmountOutLayout } from './raydium/tradeV2/type.js';
import { Structure } from './marshmallow/index.js';

interface ModuleBaseProps {
    scope: Raydium;
    moduleName: string;
}
declare class ModuleBase {
    scope: Raydium;
    private disabled;
    protected logger: Logger;
    constructor({ scope, moduleName }: ModuleBaseProps);
    protected createTxBuilder(feePayer?: PublicKey): TxBuilder;
    logDebug(...args: (string | number | Record<string, any>)[]): void;
    logInfo(...args: (string | number | Record<string, any>)[]): void;
    logAndCreateError(...args: (string | number | Record<string, any>)[]): void;
    checkDisabled(): void;
}

interface TokenAccountDataProp {
    tokenAccounts?: TokenAccount[];
    tokenAccountRawInfos?: TokenAccountRaw[];
}
declare class Account extends ModuleBase {
    private _tokenAccounts;
    private _tokenAccountRawInfos;
    private _accountChangeListenerId?;
    private _accountListener;
    private _clientOwnedToken;
    constructor(params: TokenAccountDataProp & ModuleBaseProps);
    get tokenAccounts(): TokenAccount[];
    get tokenAccountRawInfos(): TokenAccountRaw[];
    updateTokenAccount({ tokenAccounts, tokenAccountRawInfos }: TokenAccountDataProp): Account;
    addAccountChangeListener(cbk: (data: TokenAccountDataProp) => void): Account;
    removeAccountChangeListener(cbk: (data: TokenAccountDataProp) => void): Account;
    getAssociatedTokenAccount(mint: PublicKey, programId?: PublicKey): PublicKey;
    fetchWalletTokenAccounts(config?: {
        forceUpdate?: boolean;
        commitment?: Commitment;
    }): Promise<{
        tokenAccounts: TokenAccount[];
        tokenAccountRawInfos: TokenAccountRaw[];
    }>;
    getCreatedTokenAccount({ mint, programId, associatedOnly, }: {
        mint: PublicKey;
        programId?: PublicKey;
        associatedOnly?: boolean;
    }): Promise<PublicKey | undefined>;
    getOrCreateTokenAccount(params: GetOrCreateTokenAccountParams): Promise<{
        account?: PublicKey;
        instructionParams?: AddInstructionParam;
    }>;
    checkOrCreateAta({ mint, programId, autoUnwrapWSOLToSOL, }: {
        mint: PublicKey;
        programId?: PublicKey;
        autoUnwrapWSOLToSOL?: boolean;
    }): Promise<{
        pubKey: PublicKey;
        newInstructions: AddInstructionParam;
    }>;
    handleTokenAccount(params: HandleTokenAccountParams): Promise<AddInstructionParam & {
        tokenAccount?: PublicKey;
    }>;
    processTokenAccount(props: {
        mint: PublicKey;
        programId?: PublicKey;
        amount?: BigNumberish;
        useSOLBalance?: boolean;
        handleTokenAccount?: boolean;
    }): Promise<Promise<AddInstructionParam & {
        tokenAccount?: PublicKey;
    }>>;
}

declare class Farm extends ModuleBase {
    private _getUserRewardInfo;
    create<T extends TxVersion>({ poolInfo: propPoolInfo, rewardInfos, payer, programId, txVersion, }: CreateFarm<T>): Promise<MakeTxData<T, CreateFarmExtInfo>>;
    restartReward<T extends TxVersion>({ farmInfo, payer, newRewardInfo, txVersion, }: UpdateFarmReward): Promise<MakeTxData<T>>;
    restartRewards<T extends TxVersion>({ farmInfo, payer, newRewardInfos, txVersion, }: UpdateFarmRewards<T>): Promise<MakeTxData<T>>;
    addNewRewardToken<T extends TxVersion>(params: UpdateFarmReward): Promise<MakeTxData<T>>;
    addNewRewardsToken<T extends TxVersion>(params: UpdateFarmRewards<T>): Promise<MakeTxData<T>>;
    deposit<T extends TxVersion>(params: FarmDWParam<T>): Promise<MakeTxData<T>>;
    withdraw<T extends TxVersion>(params: FarmDWParam<T>): Promise<MakeTxData<T>>;
    withdrawFarmReward<T extends TxVersion>({ farmInfo, withdrawMint, txVersion, }: {
        farmInfo: FormatFarmInfoOut;
        withdrawMint: PublicKey;
        payer?: PublicKey;
        txVersion?: T;
    }): Promise<MakeTxData<T>>;
    harvestAllRewards<T extends TxVersion = TxVersion.LEGACY>(params: {
        farmInfoList: Record<string, FormatFarmInfoOut>;
        feePayer?: PublicKey;
        useSOLBalance?: boolean;
        associatedOnly?: boolean;
        checkCreateATAOwner?: boolean;
        userAuxiliaryLedgers?: string[];
        txVersion?: T;
        computeBudgetConfig?: ComputeBudgetConfig;
    }): Promise<MakeMultiTxData<T>>;
}

declare class LiquidityModule extends ModuleBase {
    constructor(params: ModuleBaseProps);
    load(): Promise<void>;
    computePairAmount({ poolInfo, amount, slippage, baseIn, }: {
        poolInfo: ApiV3PoolInfoStandardItem;
        amount: string | Decimal;
        slippage: Percent;
        baseIn?: boolean;
    }): {
        anotherAmount: TokenAmount;
        maxAnotherAmount: TokenAmount;
        liquidity: BN__default;
    };
    addLiquidity<T extends TxVersion>(params: AddLiquidityParams<T>): Promise<MakeTxData<T>>;
    removeLiquidity<T extends TxVersion>(params: RemoveParams<T>): Promise<Promise<MakeTxData<T>>>;
    removeAllLpAndCreateClmmPosition<T extends TxVersion>({ poolInfo, clmmPoolInfo, removeLpAmount, createPositionInfo, farmInfo, userFarmLpAmount, base, computeBudgetConfig, payer, tokenProgram, checkCreateATAOwner, getEphemeralSigners, txVersion, }: {
        poolInfo: ApiV3PoolInfoStandardItem;
        clmmPoolInfo: ApiV3PoolInfoConcentratedItem;
        removeLpAmount: BN__default;
        createPositionInfo: {
            tickLower: number;
            tickUpper: number;
            baseAmount: BN__default;
            otherAmountMax: BN__default;
        };
        farmInfo?: FormatFarmInfoOutV6;
        userFarmLpAmount?: BN__default;
        base: "MintA" | "MintB";
        payer?: PublicKey;
        computeBudgetConfig?: ComputeBudgetConfig;
        tokenProgram?: PublicKey;
        checkCreateATAOwner?: boolean;
        txVersion?: T;
        getEphemeralSigners?: (k: number) => any;
    }): Promise<MakeMultiTxData<T>>;
    createPoolV4<T extends TxVersion>({ programId, marketInfo, baseMintInfo, quoteMintInfo, baseAmount, quoteAmount, startTime, ownerInfo, associatedOnly, checkCreateATAOwner, tokenProgram, txVersion, feeDestinationId, computeBudgetConfig, }: CreatePoolParam<T>): Promise<MakeTxData<T, {
        address: CreatePoolAddress;
    }>>;
    getCreatePoolFee({ programId }: {
        programId: PublicKey;
    }): Promise<BN__default>;
}

declare class Clmm extends ModuleBase {
    constructor(params: ModuleBaseProps);
    load(params?: LoadParams): Promise<void>;
    createPool<T extends TxVersion>(props: CreateConcentratedPool<T>): Promise<MakeTxData<T, {
        mockPoolInfo: ApiV3PoolInfoConcentratedItem;
        address: ClmmKeys;
    }>>;
    openPositionFromBase<T extends TxVersion>({ poolInfo, poolKeys: propPoolKeys, ownerInfo, tickLower, tickUpper, base, baseAmount, otherAmountMax, associatedOnly, checkCreateATAOwner, withMetadata, getEphemeralSigners, computeBudgetConfig, txVersion, }: OpenPositionFromBase<T>): Promise<MakeTxData<T, OpenPositionFromBaseExtInfo>>;
    openPositionFromLiquidity<T extends TxVersion>({ poolInfo, poolKeys: propPoolKeys, ownerInfo, amountMaxA, amountMaxB, tickLower, tickUpper, liquidity, associatedOnly, checkCreateATAOwner, withMetadata, txVersion, getEphemeralSigners, }: OpenPositionFromLiquidity<T>): Promise<MakeTxData<T, OpenPositionFromLiquidityExtInfo>>;
    increasePositionFromLiquidity<T extends TxVersion>(props: IncreasePositionFromLiquidity<T>): Promise<MakeTxData<T, ManipulateLiquidityExtInfo>>;
    increasePositionFromBase<T extends TxVersion>(props: IncreasePositionFromBase<T>): Promise<MakeTxData<T, ManipulateLiquidityExtInfo>>;
    decreaseLiquidity<T extends TxVersion>(props: DecreaseLiquidity<T>): Promise<MakeTxData<T, ManipulateLiquidityExtInfo & Partial<ClosePositionExtInfo>>>;
    closePosition<T extends TxVersion>({ poolInfo, ownerPosition, txVersion, }: {
        poolInfo: ApiV3PoolInfoConcentratedItem;
        ownerPosition: ClmmPositionLayout;
        txVersion: T;
    }): Promise<MakeTxData<T, ClosePositionExtInfo>>;
    initReward<T extends TxVersion>({ poolInfo, ownerInfo, rewardInfo, associatedOnly, checkCreateATAOwner, computeBudgetConfig, txVersion, }: InitRewardParams<T>): Promise<MakeTxData<T, InitRewardExtInfo>>;
    initRewards<T extends TxVersion>({ poolInfo, ownerInfo, rewardInfos, associatedOnly, checkCreateATAOwner, computeBudgetConfig, txVersion, }: InitRewardsParams<T>): Promise<MakeTxData<T, {
        address: Record<string, PublicKey>;
    }>>;
    setReward<T extends TxVersion>({ poolInfo, ownerInfo, rewardInfo, associatedOnly, checkCreateATAOwner, computeBudgetConfig, txVersion, }: SetRewardParams<T>): Promise<MakeTxData<T, {
        address: Record<string, PublicKey>;
    }>>;
    setRewards<T extends TxVersion>({ poolInfo, ownerInfo, rewardInfos, associatedOnly, checkCreateATAOwner, computeBudgetConfig, txVersion, }: SetRewardsParams<T>): Promise<MakeTxData<T, {
        address: Record<string, PublicKey>;
    }>>;
    collectReward({ poolInfo, ownerInfo, rewardMint, associatedOnly, checkCreateATAOwner, }: CollectRewardParams): Promise<MakeTransaction>;
    collectRewards({ poolInfo, ownerInfo, rewardMints, associatedOnly, checkCreateATAOwner, }: CollectRewardsParams): Promise<MakeTransaction>;
    harvestAllRewards<T extends TxVersion = TxVersion.LEGACY>({ allPoolInfo, allPositions, ownerInfo, associatedOnly, checkCreateATAOwner, programId, txVersion, computeBudgetConfig, }: HarvestAllRewardsParams<T>): Promise<MakeMultiTxData<T>>;
    getWhiteListMint({ programId }: {
        programId: PublicKey;
    }): Promise<PublicKey[]>;
    computeAmountIn({ poolInfo, tickArrayCache, baseMint, token2022Infos, amountOut, slippage, priceLimit, }: {
        poolInfo: ApiV3PoolInfoConcentratedItem;
        tickArrayCache: {
            [key: string]: TickArray;
        };
        baseMint: PublicKey;
        token2022Infos: ReturnTypeFetchMultipleMintInfos;
        amountOut: BN__default;
        slippage: number;
        priceLimit?: Decimal;
    }): Promise<ReturnTypeComputeAmountOutBaseOut>;
}

declare type LiquidityPoolJsonInfo = any;
declare class TradeV2 extends ModuleBase {
    constructor(params: ModuleBaseProps);
    static getAddLiquidityDefaultPool({ addLiquidityPools, poolInfosCache, }: {
        addLiquidityPools: LiquidityPoolJsonInfo[];
        poolInfosCache: {
            [ammId: string]: PoolAccountInfoV4;
        };
    }): ReturnTypeGetAddLiquidityDefaultPool;
    private static comparePoolSize;
    private getWSolAccounts;
    unWrapWSol(props: {
        amount: BigNumberish;
        computeBudgetConfig?: ComputeBudgetConfig;
        tokenProgram?: PublicKey;
    }): Promise<MakeTransaction>;
    wrapWSol(amount: BigNumberish, tokenProgram?: PublicKey): Promise<MakeTransaction>;
    swap({ swapInfo: orgSwapInfo, associatedOnly, checkCreateATAOwner, checkTransaction, routeProgram, }: {
        swapInfo: ComputeAmountOutLayout;
        associatedOnly: boolean;
        checkCreateATAOwner: boolean;
        checkTransaction: boolean;
        routeProgram: PublicKey;
    }): Promise<MakeMultiTransaction>;
}

interface SHOW_INFO {
    programId: PublicKey;
    poolId: PublicKey;
    ammId: PublicKey;
    ownerAccountId: PublicKey;
    snapshotLpAmount: BN__default;
    openTime: number;
    endTime: number;
    project: typeof Utils1216.VERSION_PROJECT[number];
    canClaim: boolean;
    canClaimErrorType: canClaimErrorType;
    tokenInfo: {
        mintAddress: PublicKey;
        mintVault: PublicKey;
        mintDecimals: number;
        perLpLoss: BN__default;
        debtAmount: BN__default;
    }[];
}
declare type canClaimErrorType = "outOfOperationalTime" | "alreadyClaimIt" | undefined;
declare class Utils1216 extends ModuleBase {
    static CLAIMED_NUM: number;
    static POOL_LAYOUT: Structure<number | PublicKey | Buffer | BN__default | BN__default[] | {
        mintDecimals: number;
        mintAddress: PublicKey;
        mintVault: PublicKey;
        perLpLoss: BN__default;
        totalClaimedAmount: BN__default;
    }[], "", {
        padding: BN__default[];
        bump: number;
        endTime: BN__default;
        openTime: BN__default;
        status: number;
        ammId: PublicKey;
        tokenInfo: {
            mintDecimals: number;
            mintAddress: PublicKey;
            mintVault: PublicKey;
            perLpLoss: BN__default;
            totalClaimedAmount: BN__default;
        }[];
    }>;
    static OWNER_LAYOUT: Structure<number | PublicKey | Buffer | BN__default | BN__default[] | {
        mintAddress: PublicKey;
        debtAmount: BN__default;
        claimedAmount: BN__default;
    }[], "", {
        padding: BN__default[];
        owner: PublicKey;
        version: number;
        bump: number;
        poolId: PublicKey;
        tokenInfo: {
            mintAddress: PublicKey;
            debtAmount: BN__default;
            claimedAmount: BN__default;
        }[];
        lpAmount: BN__default;
    }>;
    static DEFAULT_POOL_ID: PublicKey[];
    static SEED_CONFIG: {
        pool: {
            id: Buffer;
        };
        owner: {
            id: Buffer;
        };
    };
    static VERSION_PROJECT: readonly [undefined, "Francium", "Tulip", "Larix"];
    static getPdaPoolId(programId: PublicKey, ammId: PublicKey): {
        publicKey: PublicKey;
        nonce: number;
    };
    static getPdaOwnerId(programId: PublicKey, poolId: PublicKey, owner: PublicKey, version: number): {
        publicKey: PublicKey;
        nonce: number;
    };
    static getAllInfo({ connection, programId, poolIds, wallet, chainTime, }: {
        connection: Connection;
        programId: PublicKey;
        poolIds: PublicKey[];
        wallet: PublicKey;
        chainTime: number;
    }): Promise<SHOW_INFO[]>;
    makeClaimTransaction({ poolInfo, ownerInfo, }: {
        connection: Connection;
        poolInfo: SHOW_INFO;
        ownerInfo: {
            wallet?: PublicKey;
            associatedOnly: boolean;
        };
    }): Promise<{
        transaction: Transaction;
        signer: Signer[];
    }[]>;
    makeClaimAllTransaction({ poolInfos, ownerInfo, }: {
        poolInfos: SHOW_INFO[];
        ownerInfo: {
            wallet?: PublicKey;
            associatedOnly: boolean;
        };
    }): Promise<{
        transaction: Transaction;
        signer: Signer[];
    }[]>;
    static makeClaimInstruction({ programId, poolInfo, ownerInfo, }: {
        programId: PublicKey;
        poolInfo: SHOW_INFO;
        ownerInfo: {
            wallet: PublicKey;
            ownerPda: PublicKey;
            claimAddress: PublicKey[];
        };
    }): TransactionInstruction;
}

interface ExtInfo {
    address: {
        marketId: PublicKey;
        requestQueue: PublicKey;
        eventQueue: PublicKey;
        bids: PublicKey;
        asks: PublicKey;
        baseVault: PublicKey;
        quoteVault: PublicKey;
        baseMint: PublicKey;
        quoteMin: PublicKey;
    };
}
declare class MarketV2$1 extends ModuleBase {
    create<T extends TxVersion>({ baseInfo, quoteInfo, lotSize, // 1
    tickSize, // 0.01
    dexProgramId, txVersion, }: {
        baseInfo: {
            mint: PublicKey;
            decimals: number;
        };
        quoteInfo: {
            mint: PublicKey;
            decimals: number;
        };
        lotSize: number;
        tickSize: number;
        dexProgramId: PublicKey;
        eventQueue?: PublicKey;
        requestQueue?: PublicKey;
        txVersion?: T;
    }): Promise<MakeMultiTxData<T, ExtInfo>>;
}

declare class MarketV2 extends ModuleBase {
    claim<T extends TxVersion>({ ownerInfo, idoKeys, associatedOnly, checkCreateATAOwner, txVersion, }: {
        ownerInfo: OwnerIdoInfo[keyof OwnerIdoInfo] & {
            userIdoInfo: string;
        };
        idoKeys: IdoKeysData;
        associatedOnly?: boolean;
        checkCreateATAOwner?: boolean;
        txVersion?: T;
    }): Promise<MakeTxData>;
}

interface MintToTokenAmount {
    token?: Token;
    mint: PublicKeyish;
    amount: BigNumberish;
    decimalDone?: boolean;
}
declare class TokenModule extends ModuleBase {
    private _tokenList;
    private _tokenMap;
    private _blackTokenMap;
    private _tokenPrice;
    private _tokenPriceOrg;
    private _tokenPriceFetched;
    private _mintGroup;
    private _extraTokenList;
    constructor(params: ModuleBaseProps);
    load(params?: LoadParams & {
        fetchTokenPrice?: boolean;
        type?: JupTokenType;
    }): Promise<void>;
    get tokenList(): TokenInfo[];
    get tokenMap(): Map<string, TokenInfo>;
    get blackTokenMap(): Map<string, TokenInfo>;
    get mintGroup(): {
        official: Set<string>;
        jup: Set<string>;
    };
    /** === util functions === */
    getChainTokenInfo(mint: PublicKeyish): Promise<{
        token: Token;
        tokenInfo: TokenInfo;
    }>;
    mintToToken(mint: PublicKeyish): Token;
    mintToTokenAmount({ mint, amount, decimalDone, token }: MintToTokenAmount): TokenAmount;
    decimalAmount({ mint, amount, token }: MintToTokenAmount): BN__default;
    uiAmount({ mint, amount, token }: MintToTokenAmount): string;
}

interface RaydiumLoadParams extends TokenAccountDataProp, Omit<RaydiumApiBatchRequestParams, "api"> {
    connection: Connection;
    cluster?: Cluster;
    owner?: PublicKey | Keypair;
    apiRequestInterval?: number;
    apiRequestTimeout?: number;
    apiCacheTime?: number;
    signAllTransactions?: SignAllTransactions;
    urlConfigs?: API_URL_CONFIG;
    logRequests?: boolean;
    logCount?: number;
    jupTokenType?: JupTokenType;
    preloadTokenPrice?: boolean;
    disableFeatureCheck?: boolean;
}
interface RaydiumApiBatchRequestParams {
    api: Api;
    defaultChainTimeOffset?: number;
    defaultChainTime?: number;
}
declare type RaydiumConstructorParams = Required<RaydiumLoadParams> & RaydiumApiBatchRequestParams;
interface DataBase<T> {
    fetched: number;
    data: T;
    extInfo?: Record<string, any>;
}
interface ApiData {
    tokens?: DataBase<ApiV3Token[]>;
    tokenList?: DataBase<ApiV3TokenRes>;
    jupTokenList?: {
        [JupTokenType.ALL]?: DataBase<ApiV3Token[]>;
        [JupTokenType.Strict]?: DataBase<ApiV3Token[]>;
    };
}
declare class Raydium {
    cluster: Cluster;
    farm: Farm;
    account: Account;
    liquidity: LiquidityModule;
    clmm: Clmm;
    tradeV2: TradeV2;
    utils1216: Utils1216;
    marketV2: MarketV2$1;
    ido: MarketV2;
    token: TokenModule;
    rawBalances: Map<string, string>;
    apiData: ApiData;
    availability: Partial<AvailabilityCheckAPI3>;
    private _connection;
    private _owner;
    api: Api;
    private _apiCacheTime;
    private _signAllTransactions?;
    private logger;
    private _chainTime?;
    private _epochInfo?;
    constructor(config: RaydiumConstructorParams);
    static load(config: RaydiumLoadParams): Promise<Raydium>;
    get owner(): Owner | undefined;
    get ownerPubKey(): PublicKey;
    setOwner(owner?: PublicKey | Keypair): Raydium;
    get connection(): Connection;
    setConnection(connection: Connection): Raydium;
    get signAllTransactions(): SignAllTransactions | undefined;
    setSignAllTransactions(signAllTransactions?: SignAllTransactions): Raydium;
    checkOwner(): void;
    private isCacheInvalidate;
    fetchChainTime(): Promise<void>;
    fetchV3TokenList(forceUpdate?: boolean): Promise<ApiV3TokenRes>;
    fetchJupTokenList(type: JupTokenType, forceUpdate?: boolean): Promise<ApiV3Token[]>;
    get chainTimeData(): {
        offset: number;
        chainTime: number;
    } | undefined;
    chainTimeOffset(): Promise<number>;
    currentBlockChainTime(): Promise<number>;
    fetchEpochInfo(): Promise<EpochInfo>;
    getChainTokenInfo(mint: PublicKeyish): Promise<{
        token: Token;
        tokenInfo: TokenInfo;
    }>;
    fetchAvailabilityStatus(skipCheck?: boolean): Promise<Partial<AvailabilityCheckAPI3>>;
    mintToToken(mint: PublicKeyish): Token;
    mintToTokenAmount(params: MintToTokenAmount): TokenAmount;
    solToWsolTokenAmount(tokenAmount: TokenAmount): TokenAmount;
    solToWsolTransferAmountFee(tokenAmountFee: TransferAmountFee): TransferAmountFee;
    decimalAmount(params: MintToTokenAmount): BN__default;
    uiAmount(params: MintToTokenAmount): string;
}

export { Account as A, Clmm as C, Farm as F, LiquidityModule as L, MarketV2 as M, RaydiumLoadParams as R, SHOW_INFO as S, TokenAccountDataProp as T, Utils1216 as U, RaydiumApiBatchRequestParams as a, RaydiumConstructorParams as b, Raydium as c, canClaimErrorType as d, MarketV2$1 as e, ModuleBase as f, ModuleBaseProps as g, TradeV2 as h, TokenModule as i, MintToTokenAmount as j };
